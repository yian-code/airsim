{"./":{"url":"./","title":"AirSim 简介","keywords":"","body":"AirSim 简介 资源 AirSim 官方文档 AirSim Github 仓库 宁子安 - AirSim & unreal 仿真平台 致知在格物，物格而后知至 - AirSim 理解篇 AirSim & unreal 地图资源 AirSim 是什么 AirSim 是微软公司开发的基于游戏引擎的一个开源的跨平台仿真器，它可以用于无人机、无人机车等机器人的物理和视觉仿真。它同时支持基于 PX4 和 ArduPilot 等飞行控制器的软件在环仿真，目前还支持基于 PX4 的硬件在环仿真。 AirSim 是作为虚幻游戏引擎的插件而存在的，适配基于虚幻引擎搭建的环境。目前 AirSim 也有一个实验版本的插件适用于 Unity 引擎。得益于游戏引擎优秀的视觉渲染效果，AirSim 仿真平台在具备物理仿真的同时也具备了逼真的视觉仿真效果，这是其一大亮点，非常适用于进行基于深度学习等视觉 AI 仿真验证。AirSim 提供了很多 API 接口，用于读取数据、控制车辆、控制天气等，AirSim 的开发者希望这个平台能够帮助研究人员用于深度学习、计算机视觉、强化学习等人工智能相关的研究，适用于无人机、无人驾驶、机器人等领域的应用。 AirSim 与虚幻引擎的关系 AirSim 是基于虚幻引擎开发的仿真平台，是作为虚幻引擎的插件而存在的 AirSim 与 Unity AirSim 的 Unity 版本目前还处于实验版本阶段。下面是官方的原文 Unity 上的 AirSim(实验版)Unity 是另一个很棒的游戏引擎平台，我们尝试将 AirSim 与 Unity 整合在一起。请注意，这是正在进行的工作，所有功能可能还不能工作。 代码结构 AirSim 代码结构介绍 AirSim 设计官方介绍 AirSim 的大部分代码都放在 AirLib 中，它是一个自包含库，支持任何 C++11 的编译器进行编译。 AirLib 有以下几个组件： 物理引擎：可以快速扩展实现不同的物理模型。/AirLib/include/physics 传感器模型：气压计、IMU、GPS 和磁力计的仅标头模型。/AirLib/include/sensors 物理模型：车辆配置和模型的仅标题模型。目前已经在 X 配置中实现了 MultiRotor 的模型和 PX4 QuadRotor 的配置。/AirLib/include/vehiclesr API 相关文件： 这一部分主要为 API 提供抽象基类，并为特定物理平台（如 MavLink）提供具体实现方式。它还拥有类似于 RPC 客户端和服务器的类。/AirLib/include/api common：所有常用的实用程序都在 common/ 子文件夹中进行定义。而 AirSimSettings.hpp 是一个重要文件，如果要在 settings.json 中添加任何新字段，则需要修改这个文件内容。 api 子文件夹：包含“.hpp” 文件中定义的是各种可实现的实验方法代码 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-12-09 22:37:13 "},"unity/":{"url":"unity/","title":"AirSim & Unity 环境搭建","keywords":"","body":"AirSim & Unity 环境搭建 官方文档：AirSim on Unity 软件版本 AirSim 1.8.1 Unity 2019.3.12 Visual Studio 2019, 需要安装 Desktop Development with C++ 和 Windows 10 SDK 10.0.18362 Python 版本：Python 3.7 编译 AirSim 打开 x64 Native Tools Command Prompt for VS 2019， 进入 git clone https://github.com/Microsoft/AirSim.git 下载的 AirSim 文件夹 运行 build.cmd [!TIP] 这里如果有报错请更换 Visual Studio 2022 ，需要安装 Desktop Development with C++ 和 Windows 10 SDK 10.0.19041 ，使用 Developer Command Prompt for VS 2022 进行 build 打开 AirSim\\Unity ，运行 build.cmd 测试 demo 打开 AirSim\\Unity\\UnityDemo运行工程 安装 msgpack-rpc-python 和 airsim 两个库，安装指令为： pip install msgpack-rpc-python pip install airsim 打开 AirSim\\PythonClient\\multirotor 路径，运行 hello_drone.py 文件，进行相应操作即可控制无人机 操作： 相机视角控制按键：数字键 0 1 2 3 数据记录按键：游戏视图右下角的红色按钮，所记录的数据可以在计算机的 Documents\\AirSim\\(Date of recording) 找到 Fn + F10 打开天气控制开关 bug 记录 之前参考过这个Windows10 安装并使用 Unity3D 项目 AirSim 教程 错误 MSB8020 无法找到 v143 的生成工具(平台工具集 =“v143”)。若要使用 v143 生成工具进行生成，请安装 v143 生成工具，使用过方法 无法找到 v143 的生成工具解决了 使用 vs2022 编译运行报错问题 目前为了使用 AirSim & UE4 ，本人使用的 vs 2022 编译的 AirSim ，但是执行 hello_drone.py错误： PS F:\\AirSim\\PythonClient\\multirotor> python .\\hello_drone.py Traceback (most recent call last): File \".\\hello_drone.py\", line 13, in state = client.getMultirotorState() NameError: name 'client' is not defined 由于之前使用 vs2019 的工程有存档，现在暂时使用原先的存档进行学习开发 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-11-26 23:05:51 "},"unity/1.html":{"url":"unity/1.html","title":"setting 设置","keywords":"","body":"setting 设置 SubWindows: 开始运行时候子窗口显示的相机内容 Recording：记录功能允许您记录数据，如位置，方向，速度随着捕获的图像在指定的间隔。你可以按右下的红色录音按钮或 R 键开始录音。数据存储在 Documents (Airsim 文件夹(或使用 folder 指定的文件夹)中，在每个录音会话的时间戳子文件夹中，作为制表符分隔的文件。 RecordOnMove：位置不变的时候是否记录帧数据 RecordInterval：时间间隔 Folder：创建父文件夹,包含带有时间戳的记录子文件夹。必须指定目录的绝对路径。如果没有，则路径默认为 Documents/AirSim Enabled: 是否录音 Cameras：捕获图像，可保存多个相机图像 { \"SimMode\": \"Multirotor\", \"SettingsVersion\": 1.2, \"SeeDocsAt\": \"https://github.com/Microsoft/AirSim/blob/main/docs/settings.md\", \"Recording\": { \"RecordOnMove\": false, \"RecordInterval\": 0.05, \"Folder\": \"\", \"Enabled\": false, \"Cameras\": [ { \"CameraName\": \"1\", \"ImageType\": 3, \"PixelsAsFloat\": false, \"VehicleName\": \"hongwai\", \"Compress\": true } ] }, \"SubWindows\": [ { \"WindowID\": 0, \"ImageType\": 1, \"CameraName\": \"0\", \"Visible\": true }, { \"WindowID\": 1, \"ImageType\": 3, \"CameraName\": \"1\", \"Visible\": true }, { \"WindowID\": 2, \"ImageType\": 7, \"CameraName\": \"2\", \"Visible\": true } ] } Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-11-26 19:31:31 "},"unity/3.html":{"url":"unity/3.html","title":"hello Drone","keywords":"","body":"hello Drone hello_drone.py 运行 unity demo，我们可以使用 AirSim 提供的示例来控制无人机 打开 AirSim\\PythonClient\\multirotor, 运行 hello_drone.py import setup_path import airsim import numpy as np import os import tempfile import pprint import cv2 # connect to the AirSim simulator state = client.getMultirotorState() s = pprint.pformat(state) print(\"state: %s\" % s) imu_data = client.getImuData() s = pprint.pformat(imu_data) print(\"imu_data: %s\" % s) barometer_data = client.getBarometerData() # 气压计数据 s = pprint.pformat(barometer_data) print(\"barometer_data: %s\" % s) magnetometer_data = client.getMagnetometerData() # 磁力计数据 s = pprint.pformat(magnetometer_data) print(\"magnetometer_data: %s\" % s) gps_data = client.getGpsData() s = pprint.pformat(gps_data) print(\"gps_data: %s\" % s) airsim.wait_key('Press any key to takeoff') print(\"Taking off...\") client.armDisarm(True) client.takeoffAsync().join() state = client.getMultirotorState() print(\"state: %s\" % pprint.pformat(state)) airsim.wait_key('Press any key to move vehicle to (-10, 10, -10) at 5 m/s') client.moveToPositionAsync(-10, 10, -10, 5).join() client.hoverAsync().join() state = client.getMultirotorState() print(\"state: %s\" % pprint.pformat(state)) airsim.wait_key('Press any key to take images') # get camera images from the car responses = client.simGetImages([ airsim.ImageRequest(\"0\", airsim.ImageType.DepthVis), #depth visualization image airsim.ImageRequest(\"1\", airsim.ImageType.DepthPerspective, True), #depth in perspective projection airsim.ImageRequest(\"1\", airsim.ImageType.Scene), #scene vision image in png format airsim.ImageRequest(\"1\", airsim.ImageType.Scene, False, False)]) #scene vision image in uncompressed RGBA array print('Retrieved images: %d' % len(responses)) tmp_dir = os.path.join(tempfile.gettempdir(), \"airsim_drone\") print (\"Saving images to %s\" % tmp_dir) try: os.makedirs(tmp_dir) except OSError: if not os.path.isdir(tmp_dir): raise for idx, response in enumerate(responses): filename = os.path.join(tmp_dir, str(idx)) if response.pixels_as_float: print(\"Type %d, size %d\" % (response.image_type, len(response.image_data_float))) airsim.write_pfm(os.path.normpath(filename + '.pfm'), airsim.get_pfm_array(response)) elif response.compress: #png format print(\"Type %d, size %d\" % (response.image_type, len(response.image_data_uint8))) airsim.write_file(os.path.normpath(filename + '.png'), response.image_data_uint8) else: #uncompressed array print(\"Type %d, size %d\" % (response.image_type, len(response.image_data_uint8))) img1d = np.fromstring(response.image_data_uint8, dtype=np.uint8) # get numpy array img_rgb = img1d.reshape(response.height, response.width, 3) # reshape array to 4 channel image array H X W X 3 cv2.imwrite(os.path.normpath(filename + '.png'), img_rgb) # write to png airsim.wait_key('Press any key to reset to original state') client.reset() client.armDisarm(False) # that's enough fun for now. let's quit cleanly client.enableApiControl(False) Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-11-26 19:46:40 "},"unity/2.html":{"url":"unity/2.html","title":"使用 DroneShell 控制无人机","keywords":"","body":"使用 DroneShell 控制无人机 DroneShell 演示了如何使用 UDP 连接到模拟器。 模拟器正在运行服务器（类似于 DroneServer） 使用 DroneShell 控制无人机： 运行 unitydemo ，启动本地服务器 运行 AirSim\\PythonClient\\multirotor>python hello_drone.py 使用 vs2022 打开 AirSim\\DroneShell\\DroneShell.vcxproj 工程，使用 Debug x64 模式调试运行，等待连接本地服务器，连接成功即可使用脚本控制无人机 Arm Arm the motors so the drone is ready to fly BackForthByAngle Make drone go in linear motion back and forth using pitch/roll BackForthByPosition Make drone go in linear motion back and forth two x positions CircleByPath Make drone go in circle using path commands CircleByPosition Make drone go in square using position commands Disarm Disarm the motors so we can safely approach the drone GetGeoHomePoint Display the home geo_point set in the drone GetImage Get an image from the simulator GoHome Go back to takeoff point and land Hover Enter hover mode Land Land the drone MoveByAngleThrottle Move with specified roll and pitch, leaving z as-is MoveByAngleZ Move with specified roll and pitch, leaving z as-is MoveByManual Move using remote control manually MoveByVelocity Move by specified velocity components vx, vy, vz, axis wrt body MoveByVelocityZ Move by specified velocity components vx, vy, and fixed z MoveOnPath Move along the given series of x,y,z coordinates with the specified velocity MoveToPosition Move to x,y,z with specified velocity MoveToZ Move to z in meters (measured from launch point) with given velocity in m/s PlayPose Fly the drone through each recorded pose found in log file named 'rec_pos.log' in your $HOME folder See RecordPose for information about log file format Pos Get the current position RecordPose Append a single pose snapshot to a log file named 'rec_pos.log' in your $HOME folder Each record is tab separated floating point numbers containing GPS lat,lon,alt,z,health, position x,y,z, and quaternion w,x,y,z ReleaseControl Release offboard control of drone RequestControl Take offboard control of drone Rotate Rotate with angular velocity in degrees/s for given time in seconds RotateTo Rotate to a particular angle SetSafety Set safety parameters SquareByAngle Make drone go in square using pitch/roll SquareByPath Make drone go in square using path commands SquareByPosition Make drone go in square using position commands TakeOff Drone takeoff to a default altitude help Help on the supported commands or Help [Command] for help on a specific command ? same as help quit Exit the shell q same as quit exit same as quit rem Comment out the line # same as rem run Run script specified in file Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-11-26 19:57:21 "},"unity/4.html":{"url":"unity/4.html","title":"AirSim & Unity 多无人机","keywords":"","body":"AirSim & Unity 多无人机机 settings { \"SimMode\": \"Multirotor\", \"SettingsVersion\": 1.2, \"Vehicles\": { \"Drone1\": { \"VehicleType\": \"SimpleFlight\", \"X\": 0, \"Y\": 0, \"Z\": 0, \"Yaw\": 0 }, \"Drone2\": { \"VehicleType\": \"SimpleFlight\", \"X\": 2, \"Y\": 0, \"Z\": 0, \"Yaw\": 0 } } } [!TIP] unity 中的多机与 UE 中的不同，UE 中不用提前关联脚本，而 unity 中必须将无人机对象与 Drone 脚本对应 settings 初始化 多机上的 Drone 脚本 /* * Drone component that is used to control the drone object in the scene. This is based on Vehicle class that is communicating with AirLib. * 无人机组件，用于控制场景中的无人机对象。这是基于与AirLib通信的Vehicle类。 * This class depends on the AirLib's drone controllers based on FastPhysics engine. The controller is being used based on setting.json file in Documents\\AirSim * 这个类依赖于基于FastPhysics引擎的AirLib无人机控制器。控制器根据设置正在被使用。Documents\\AirSim . json文件 * The drone can be controlled either through keyboard or through client api calls. * 无人机可以通过键盘或通过客户端api调用控制。 * This data is being constantly exchanged between AirLib and Unity through PInvoke delegates. * 这些数据通过PInvoke委托在AirLib和Unity之间不断交换。 */ Unity 使用 simAddVehicle API 添加无人机报错 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-12-06 01:56:56 "},"ue/":{"url":"ue/","title":"AirSim & Unreal 环境搭建","keywords":"","body":"AirSim & Unreal 仿真平台环境搭建 2022-11-25 晚 参考教程：airsim 详细教程(1)：win10 配置 airsim 仿真环境 2022-11-26 晚 [!WARNING] > Upgrading to Unreal Engine 4.27 这是官网的使用 Unreal Engine 4.27 的环境配置教程，如果你使用的是 4.27 版本或者从 4.25 版本升级到此就需要看这个了 软件版本： AirSim 版本：v1.8.1 虚幻引擎版本：4.27 Visual Studio 版本：Visual Studio Community 2022 Python 版本：Python 3.7 使用 Developer Command Prompt for VS 2022 进入 AirSim 文件夹运行 build.cmd 进行编译 Block 环境测试：使用 Developer Command Prompt for VS 2022 进入 Airsim\\Unreal\\Environments\\Blocks 运行指令 update_from_git.bat, 生成 Blocks.sln 工程文件，双击打开此工程文件，会自动运行 Visual Studio 2022 将 Block工程 设置为启动项目，编译设置为 DebugGame_Editor 和 Win64 然后 调试 -> 开始调试 就会打开 Unreal Engine 点击运行，按数字键 0 即可打开相机画面 [!TIP] Shift + F1 ：显示出鼠标指针 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-11-28 19:54:51 "},"ue/1.html":{"url":"ue/1.html","title":"在 UE 工程中使用 AirSim","keywords":"","body":"在 UE 工程中使用 AirSim 参考教程： 官方文档：Creating and Setting Up Unreal Environment 浏览游戏中的美景（CV mode） 山脉景观环境是一个免费的，非常经典的官方教程用环境 环境下载 打开 Epic Game Launcher, 点击 Learn 按钮，然后往下滑，找到 山脉景观，点进去之后，点击 Create Project，选择安装位置，然后点击 Create，就开始下载了，下载和安装都是自动的。在左下有一个 Downloads 按钮可以查看下载安装的详细情况。 为了能够使用 Visual Studio 编译.sln 文件，我们需要创建自己的类，因为 Unreal 要求至少有一个源文件。具体步骤是：点击左上角的文件，选择新建 C++类，父类选择无，所以直接点击下一步；命名和路径都是默认就好了，直接点击创建类。这时 Unreal 会自动编译 C++代码，然后会自动打开 Visual Studio。到此 MountainAirSim 环境就下载安装好了。 在环境中添加 AirSim 插件 在环境中添加 AirSim 插件: 找到 AirSim\\Unreal\\Plugins 文件夹，并将其复制到 MountainAirSim 工程文件夹中。 使用记事本打开 MountainAirSim.uproject 文件，修改为如下 { \"FileVersion\": 3, \"EngineAssociation\": \"4.24\", \"Category\": \"Samples\", \"Description\": \"\", \"Modules\": [ { \"Name\": \"LandscapeMountains\", \"Type\": \"Runtime\", \"LoadingPhase\": \"Default\", \"AdditionalDependencies\": [\"AirSim\"] } ], \"TargetPlatforms\": [\"MacNoEditor\", \"WindowsNoEditor\"], \"Plugins\": [ { \"Name\": \"AirSim\", \"Enabled\": true } ], \"EpicSampleNameHash\": \"1226740271\" } 然后右键点击 MountainAirSim.uproject 选择 Generate Visual Studio project files 双击打开 MountainAirSim.sln，会自动打开 Visual Studio，选择编译选项为DebugGame Editor和Win64`，同时确保 MountainAirSim 为启动项目。 点击 本地 Windows 调试器， 这时会打开 Unreal 编辑器。这时 Unreal 就已经能够识别 airsim 插件了，你可以在 Unreal 编辑器中修改环境、assets 和其他游戏相关的设置。首先一定要改的是将仿真模式改成 AirsimGameMode，在 Unreal 编辑器中，选择窗口 -> 世界场景设置中的 Game Mode，选择 游戏模式覆盖 为 AirsimGameMode，并且要按 Ctrl+S 来保存环境。 环境中建议的初始设置 游戏玩家初始位置设置 首先比较重要的是 PlayerStart 设置，这个设置的目的是更改游戏开始的时候，玩家的初始位置。如果你是想做无人机仿真，那么仿真开始的时候，PlayerStart 就是四旋翼无人机的初始位置，也就是全局坐标的原点。如果这个点设置到了地表以下，那么飞机是无法飞到天空中的；如果这个点设置到了很高的高空中，那么仿真一开始，四旋翼会直接极速坠落；所以最好将这个点设置到地面以上 1 米以内的位置上。 在右上的 世界大纲视图 下面的搜索框中搜索 PlayerStart，你会发现这个环境中有不止一个 PlayerStart。最好将后面的几个都删除掉，只留下一个。双击最后剩下的一个 PlayerStart， 这时，中间的画面会直接到了这个初始位置，在中间的画面中，滚动鼠标滚轮可以拉长和拉近视角；把鼠标放在中间的白点或者红绿蓝三个坐标轴上时，用鼠标左键可以拖动 PlayerStart，以此来改变 PlayerStart 的位置。还有一种方法可以改变 PlayerStart 的位置，在右下角的细节窗口下，只用输入坐标即可。更改完之后，记得保存环境。这样下次打开的时候，初始位置还是你设置过的位置。 优化 CPU 使用设置 此外还有一个比较重要的设置是：编辑->编辑器偏好设置，搜索 CUP 找到 处于背景时占用较少 CPU 的设置选项。如果勾选了这个选项，那么当做 Unreal 编辑器不在窗口的最前面时，就不会实时渲染了，但是不影响仿真的运行。所以还是建议勾选。 显示实时 fps 设置 点击中间画面中左上角的下三角，勾选显示 FPS，此时右边就会出现当前的 FPS 和时延。当 FPS 下降到 20 以内时，说明数据处理比较缓慢，需要找到问题所在，并优化程序。FPS 在 20 以上算是比较流畅的。 设置为 Computer Vision Mode 一种仿真模式：Computer Vision Mode，让你可以用键盘来控制游戏中的视角，然后就可以自由浏览游戏中的美景。 在 C:\\用户{用户名}\\文档\\下面新建 AirSim 文件夹， 在新建的 AirSim 文件夹中新建 settings.json 文件。如果运行过 airsim 的话，应该会默认创建这个文件夹和文件的，如果没有，则需要手动创建。将 settings.json 文件修改为如下所示： { \"SettingsVersion\": 1.2, \"SimMode\": \"ComputerVision\" } 这里的设置就是运行 airsim 的时候首先读取的设置，这里的 SimMode 可以设置为 Car、Multirotor ，分别对应小车、四旋翼无人机。这样在仿真的时候就不用选择是用小车还是无人机了。本次我们设置为 ComputerVision 模式。 在 Unreal 编辑器中，点击播放，如果是第一次点击播放，可能需要一些时间来渲染画面。 在中间的画面中点击一下鼠标左键，这时就可以用键盘来控制视角了。 上下左右按键：控制前后左右移动 PgUp、PgDn：控制上下移动 w、s 按键：控制俯仰 a、d 按键：控制偏航 使用这些按键可以自由地在景色中移动，浏览美景。 在浏览模式中，鼠标是不能移动的，同时按 shift+F1，就退出了浏览模式，这时鼠标就出来了。 这个 MountainAirSim 环境中有比较大的雾气，会影响视觉效果。在右边的搜索框找到 ExponentialHeightFog Actor,，然后在下面的细节选项卡中，将雾密度设为 0。 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-11-26 23:04:09 "},"ue/2.html":{"url":"ue/2.html","title":"用遥控器开飞机","keywords":"","body":"用遥控器开飞机 由于本人没有现成的遥控进行测试，后续有机会再补 参考资源：宁子安 - airsim 详细教程(三) - 用遥控器开飞机 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-11-26 19:20:49 "},"ue/3.html":{"url":"ue/3.html","title":"控制四旋翼起飞和降落(airsim api)","keywords":"","body":"控制四旋翼起飞和降落(airsim api) AirSim APIs AirSim 封装了一些 API 接口，使用这些 API 接口，可以用程序跟仿真进行交互。例如可以使用 API 来获取图片、无人机状态、控制无人机/车辆的运动等。 AirSim 的 API 非常丰富，有很多可以调用的功能，可以将这些功能分成以下几类： 图像类 API ：获取各种类型的图像、控制云台等； 控制仿真运行 ：可以控制仿真暂停或继续； 碰撞 API ：获取碰撞信息，包括碰撞次数、位置、表面信息、渗透深度等； 环境时间 API ：主要是控制太阳在天空中的位置； 环境天气 API ：控制环境中的天气：下雨、雪、灰尘、雾气、道路湿滑程度等； 环境风 API ：控制环境中的风速和风向等； 雷达 API ：添加和控制环境中的雷达传感器； 无人机或车辆的 API ：控制运动、获取状态等， AirSim 的 API 有 python 和 C++两种使用方式，可以根据自己的习惯任意选择。 控制四旋翼起飞和降落 安装 msgpack-rpc-python 和 airsim 两个库，安装指令为： pip install msgpack-rpc-python pip install airsim py 程序 # 使用 python 做AirSim仿真，必须导入 airsim 包。 import airsim # connect to the AirSim simulator # 与 AirSim 建立连接，并且返回句柄（client），后面的每次操作需要使用这个句柄。 # 如果是汽车仿真，代码是：client = airsim.CarClient() client = airsim.MultirotorClient() # 检查通信是否建立成功，并且会在命令行中打印连接情况 client.confirmConnection() # get control 获取控制权 client.enableApiControl(True) # unlock 解锁 client.armDisarm(True) # Async methods returns Future. Call join() to wait for task to complete. client.takeoffAsync().join() # 起飞 client.landAsync().join() # 降落 # lock 上锁 client.armDisarm(False) # release control 释放控制权 client.enableApiControl(False) 设置仿真模式：将 C:\\Users[用户名]\\Documents\\AirSim 路径下的 settings.json 文件中的仿真模式改为多旋翼。 { \"SettingsVersion\": 1.2, \"SimMode\": \"Multirotor\" } 双击打开 MountainAirSim.sln，会自动打开 Visual Studio，选择编译选项为 DebugGame Editor 和 Win64，同时确保 MountainAirSim 为启动项目。点击 本地 Windows 调试器，这时会打开 Unreal Editor；在 Unreal Editor 中点击 播放(Play) 按钮，仿真就会运行。 运行 py 程序即可看见无人机先起飞飞到一定的高度再降落 python 与 AirSim 的通信机制 AirSim API 使用的是 TCP/IP 中的 msgpack-rpc 协议，这是一种网络通信协议，所以如果设置正确，其实可以用两台不同的电脑来做仿真，一台跑 AirSim 和 Unreal，另一台跑 python 程序。 当 AirSim 开始仿真的时候，会打开 41451 端口，并监听这个端口的需求。python 程序使用 msgpack serialization 格式向这个端口发送 RPC 包，就可以与 AirSim 进行通信了。 如果你的计算机的 41451 端口已经被其他程序使用了，那么可以通过 settings 文件改变 AirSim 使用的端口号。关于 Settings 文件，我们在后面的文章中详细讲解。 使用这种网络通信协议的方式，可以将 AirSim 和 python 程序隔离，互不干扰。所以不需要修改 AirSim 的任何源代码，就可以满足非常多的仿真需求；而且即使 python 程序中断了，AirSim 的仿真也可以继续进行。 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-11-26 21:12:19 "},"ue/4.html":{"url":"ue/4.html","title":"控制四旋翼的飞行(core api)","keywords":"","body":"控制四旋翼的飞行(core api) 四旋翼飞正方形代码 import airsim import time ​ # connect to the AirSim simulator client = airsim.MultirotorClient() ​ client.enableApiControl(True) # get control client.armDisarm(True) # unlock client.takeoffAsync().join() # takeoff ​ # square flight client.moveToZAsync(-3, 1).join() # 上升到3m高度 client.moveToPositionAsync(5, 0, -3, 1).join() # 飞到（5,0）坐标 client.moveToPositionAsync(5, 5, -3, 1).join() # 飞到（5,5）坐标 client.moveToPositionAsync(0, 5, -3, 1).join() # 飞到（0,5）坐标 client.moveToPositionAsync(0, 0, -3, 1).join() # 回到（0,0）坐标 ​ client.landAsync().join() # land client.armDisarm(False) # lock client.enableApiControl(False) # release control 当仿真时飞机不是朝向正前方的时候，需要设置 player start 的位置角度，将其改成 0 即可。 代码解读 moveToZAsync(z, velocity) 是高度控制 API，第一个参数是高度，第二个参数是速度。实现的效果是以 1m/s 的速度飞到 3 米高。 .join() 后缀的意思是程序在这里等待直到任务完成，也就是四旋翼达到 3 米的高度。如果不加 .join() 后缀，则不用等待任务是否完成，函数直接返回，程序继续往下执行。 moveToPositionAsync(x, y, z, velocity) 是水平位置控制 API，x,y,z 是全局坐标位置，velocity 是速度。 AirSim 坐标系定义 Unreal 引擎中的坐标系与 AirSim 定义的坐标系是不同的，甚至长度单位都不同。Unreal 的长度单位是厘米，而 AirSim 的长度单位是米。不过不用担心，AirSim 已经非常好的处理了这个问题，你不用管 Unreal 的坐标系是什么，只需要按照 AirSim 的坐标系设置即可，AirSim 会帮你自动转换的。 全局坐标系、机体坐标系。 全局坐标系是固连到大地的，x,y,z 三个坐标轴的指向分别是北，东，地，也就是朝北是 x 轴的正方向，朝南就是 x 轴的负方向。全局坐标系的原点位置是大地的某一点（可以在 settings 文件中设置）。 机体坐标系是固连到四旋翼机身的，x,y,z 三个坐标轴的指向分别是前，右，下，也就是飞机的前方是 x 轴的正方向，飞机后方是 x 轴的负方向。机体坐标系的原点位置是机体的重心位置。 将 playerStart 的旋转都设为 0 ，那么仿真刚开始的时候，四旋翼的机体坐标系与全局坐标系是重合的。 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-11-26 21:49:59 "},"ue/5.html":{"url":"ue/5.html","title":"四旋翼飞正方形(速度控制)","keywords":"","body":"四旋翼飞正方形(速度控制) 相机视角 点击 运行/Play 按钮后，中间的视角默认是跟随视角，视角的设置决定了摄像机如何跟随四旋翼，对于四旋翼来说，默认是跟随/Flywithme 模式，对于汽车来说，默认是 SpringArmChase 模式。下面列出这些模式： 按键 模式 解释 B 跟随/FlyWithMe 以 6 自由度跟随四旋翼 F FPV 机载摄像头视角 \\ 地面观察者/GroundObserver 在地面上以 XY 平面自由度跟随四旋翼 M 手动/Manual 手动设置摄像机的位置 / 弹性机臂跟随/SpringArmChase 摄像机固定在一个隐形的与汽车连在一起的弹性机臂上，跟随汽车，所以会有一些时延 NoDisplay 不显示画面，这可以提高渲染性能，而且不影响 APIs 按 M 按键进入手动设置模式，可以设置摄像机的位置： 方向键：前进、后退、向左、向右移动 page up/down：上下移动 W，S 按键：俯仰转动 A，D 按键：偏航转动 四旋翼飞正方形 import airsim import time ​ client = airsim.MultirotorClient() # connect to theAirSim simulator client.enableApiControl(True) # 获取控制权 client.armDisarm(True) # 解锁 client.takeoffAsync().join() # 第一阶段：起飞 ​ client.moveToZAsync(-2, 1).join() # 第二阶段：上升到2米度 ​ # 飞正方形 client.moveByVelocityZAsync(1, 0, -2, 8).join() # 第阶段：以1m/s速度向前飞8秒钟 client.moveByVelocityZAsync(0, 1, -2, 8).join() # 第阶段：以1m/s速度向右飞8秒钟 client.moveByVelocityZAsync(-1, 0, -2, 8).join() # 第阶段：以1m/s速度向后飞8秒钟 client.moveByVelocityZAsync(0, -1, -2, 8).join() # 第阶段：以1m/s速度向左飞8秒钟 ​ # 悬停 2 秒钟 client.hoverAsync().join() # 第四阶段：悬停6秒钟 time.sleep(6) ​ client.landAsync().join() # 第五阶段：降落 client.armDisarm(False) # 上锁 client.enableApiControl(False) # 释放控制权 速度控制 API： def moveByVelocityZAsync( self, vx, # 全局坐标系下x轴方向上的速度 vy, # 全局坐标系下y轴方向上的速度 z, # 全局坐标系下的高度 duration, # 持续的时间，单位：秒 drivetrain=DrivetrainType.MaxDegreeOfFreedom, # 偏航控制 yaw_mode=YawMode(), vehicle_name=\"\", # 在多机协同的时候再用到 ) [!TIP] 四旋翼是一个非线性系统，给一个速度指令，它是不可能瞬时达到的，而且这个速度指令与当前的速度之差越大，到达这个速度指令的调节时间就越长。所以在上面的程序中，最后的四旋翼并没有回到起点位置。 python 多线程（飞行同时打印 GPS 信息） [!TIP] AirSim 可以同时进行两个连接，两个线程不能共用一个 client = airsim.MultirotorClient()，两个线程共用一个连接会报通讯协议相关错误 import airsim import time import threading client = airsim.MultirotorClient() # connect to the AirSim simulator client2 = airsim.MultirotorClient() client.enableApiControl(True) # 获取控制权 client.armDisarm(True) # 解锁 client.takeoffAsync().join() # 第一阶段：起飞 def GetGps(): while True: gps_data = client2.getGpsData() print(gps_data.gnss.geo_point) time.sleep(2) t1 = threading.Thread(target=GetGps) t1.start() client.moveToZAsync(-2, 1).join() # 第二阶段：上升到2米高度 # 飞正方形 client.moveByVelocityZAsync(8, 0, -2, 2).join() # 第三阶段：以8m/s速度向前飞2秒钟 client.moveByVelocityZAsync(0, 8, -2, 2).join() # 第三阶段：以8m/s速度向右飞2秒钟 client.moveByVelocityZAsync(-8, 0, -2, 2).join() # 第三阶段：以8m/s速度向后飞2秒钟 client.moveByVelocityZAsync(0, -8, -2, 2).join() # 第三阶段：以8m/s速度向左飞2秒钟 # 悬停 2 秒钟 client.hoverAsync().join() # 第四阶段：悬停6秒钟 time.sleep(6) client.landAsync().join() # 第五阶段：降落 client.armDisarm(False) # 上锁 client.enableApiControl(False) # 释放控制权 # gps_data: # # { # 'gnss': # { # 'eph': 0.12108179926872253, # 'fix_type': 3, # 'geo_point': { 'altitude': 114.63304901123047, # 'latitude': 47.641468000001176, # 'longitude': -122.14016499999315 # }, # 'time_utc': 1669858302378736, # 'velocity': { 'x_val': -3.9472894286518567e-07, # 'y_val': -1.6675492133799708e-06, # 'z_val': -0.4948185384273529 # } # }, # 'is_valid': True, # 'time_stamp': 1669858302378736640 # } Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-12-01 11:38:33 "},"ue/6.html":{"url":"ue/6.html","title":"Unreal 环境及模型设置","keywords":"","body":"Unreal 环境及模型设置 参考： 使用 Unreal MarketPlace 中的环境 导入第三方静态模型 改变无人机的形状 Airsim-如何利用 3Dmax 整理新的四旋翼模型 这部分操作与 AirSim 没什么关系，在网上找 UE4 教程即可 天气设置 天气的影响按 F10 （Fn + F10）查看天气效果的各种选项。你也可以用 api 控制天气。按 F1 （Fn + F1）查看其他可用选项。 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-11-26 22:53:00 "},"ue/7.html":{"url":"ue/7.html","title":"无人机相关 API 总结","keywords":"","body":"无人机相关 API 总结 参考资源： 无人机相关 API 总结 AirSim Python API 随着后续学习补充 源码： AirSim\\AirLib\\src\\vehicles\\multirotor\\api\\MultirotorApiBase.cpp AirSim\\AirLib\\src\\vehicles\\multirotor\\api\\MultirotorRpcLibClient.cpp AirSim\\AirLib\\src\\vehicles\\multirotor\\api\\MultirotorRpcLibServer.cpp 无人机起飞降落 # 起飞 client.takeoffAsync(timeout_sec = 20, vehicle_name = '') # 降落 client.landAsync( timeout_sec = 60, vehicle_name = '') # 回到起始位置 client.goHomeAsync(timeout_sec = 3e+38, vehicle_name = '') #悬停 client.hoverAsync(vehicle_name = '') 获取无人机状态 获取估计状态 [!WARNING] 这个状态是由传感器估计的状态，并不是无人机状态的真值。AirSim 默认的无人机底层飞控 simple_flight 并不支持状态估计，所以如果是 simple_flight 飞控，此函数得到的状态与真值相同。 使用 PX4 飞控可以获取估计的状态 state = client.getMultirotorState(vehicle_name = '') 其中无人机的状态变量 state 包含如下： class MultirotorState(MsgpackMixin): collision = CollisionInfo() # 碰撞信息 kinematics_estimated = KinematicsState() # 状态信息 gps_location = GeoPoint() # GPS 信息 timestamp = np.uint64(0) # 时间戳 landed_state = LandedState.Landed # 是否是降落状态 rc_data = RCData() # 遥控器数据 ready = False ready_message = \"\" can_arm = False 状态信息的定义： class KinematicsState(MsgpackMixin): position = Vector3r() # 位置 orientation = Quaternionr() # 姿态角 linear_velocity = Vector3r() # 速度 angular_velocity = Vector3r() # 机体角速率 linear_acceleration = Vector3r() # 加速度 angular_acceleration = Vector3r() # 机体角加速度 GPS 信息包含： class GeoPoint(MsgpackMixin): latitude = 0.0 longitude = 0.0 altitude = 0.0 获取状态真值 kinematics_state = client.simGetGroundTruthKinematics(vehicle_name = '') 无人机控制 # 位置控制: x，y，z是全局坐标系下的三维位置坐标指令 client.moveToPositionAsync(x, y, z, velocity, timeout_sec = 3e+38, drivetrain = DrivetrainType.MaxDegreeOfFreedom, yaw_mode = YawMode(),lookahead = -1, adaptive_lookahead = 1, vehicle_name = '') # 速度控制: vx，vy，vz是全局坐标系(NED)下的速度指令 client.moveByVelocityAsync(vx, vy, vz, duration, drivetrain = DrivetrainType.MaxDegreeOfFreedom, yaw_mode = YawMode(), vehicle_name = '') # 水平速度控制（指定高度）: vx，vy是全局坐标系(NED)下的速度指令，z是全局高度指令 client.moveByVelocityZAsync(vx, vy, z, duration, drivetrain = DrivetrainType.MaxDegreeOfFreedom, yaw_mode = YawMode(), vehicle_name = '') # 水平姿态角控制（指定高度）: pitch, roll是水平姿态角指令，z 是全局高度指令，yaw是偏航角指令 client.moveByAngleZAsync(pitch, roll, z, yaw, duration, vehicle_name = '') # 高度控制: z 是全局高度指令，velocity是垂直速度 client.moveToZAsync(z, velocity, timeout_sec = 3e+38, yaw_mode = YawMode(), lookahead = -1, adaptive_lookahead = 1, vehicle_name = '') # 偏航角控制 client.rotateToYawAsync(yaw, timeout_sec = 3e+38, margin = 5, vehicle_name = '') # 偏航角速率控制 client.rotateByYawRateAsync(yaw_rate, duration, vehicle_name = '') # 沿路径飞行 client.moveOnPathAsync(path, velocity, timeout_sec = 3e+38, drivetrain = DrivetrainType.MaxDegreeOfFreedom, yaw_mode = YawMode(),lookahead = -1, adaptive_lookahead = 1, vehicle_name = '') # 遥控器控制: 由遥控器信号控制，vx_max, vy_max是速度限制，z_min 是最低高度限制。 client.moveByManualAsync(vx_max, vy_max, z_min, duration, drivetrain = DrivetrainType.MaxDegreeOfFreedom, yaw_mode = YawMode(), vehicle_name = '') 无人机底层飞控 直接控制四个电机 client.moveByMotorPWMsAsync(front_right_pwm, rear_left_pwm,front_left_pwm, rear_right_pwm, duration, vehicle_name = '') 姿态角控制、指定高度控制。roll, pitch, yaw 姿态角指令，z 高度指令 client.moveByRollPitchYawZAsync(roll, pitch, yaw, z, duration,vehicle_name = '') 姿态角控制、高度油门控制 client.moveByRollPitchYawThrottleAsync(roll, pitch, yaw, throttle,duration, vehicle_name = '') 俯仰翻滚姿态角、偏航角速率、高度油门控制 client.moveByRollPitchYawrateThrottleAsync(roll, pitch, yaw_rate, throttle, duration, vehicle_name = '') 俯仰翻滚姿态角、偏航角速率、指定高度控制 client.moveByRollPitchYawrateZAsync(roll, pitch, yaw_rate, z, duration, vehicle_name = '') 姿态角速率、指定高度 client.moveByAngleRatesZAsync(roll_rate, pitch_rate, yaw_rate, z, duration, vehicle_name = '') 姿态角速率、高度油门控制 client.moveByAngleRatesThrottleAsync(roll_rate, pitch_rate, yaw_rate, throttle, duration, vehicle_name = '') 更改角速度环控制器参数 client.setAngleRateControllerGains( angle_rate_gains=AngleRateControllerGains(), vehicle_name = '') 更改角度环控制器参数 client.setAngleLevelControllerGains(angle_level_gains=AngleLevelControllerGains(), vehicle_name = '') 更改速度环控制器参数 client.setVelocityControllerGains(velocity_gains=VelocityControllerGains(), vehicle_name = '') 更改位置环控制器参数 client.setPositionControllerGains(position_gains=PositionControllerGains(), vehicle_name = '') Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-12-01 13:49:22 "},"ue/8.html":{"url":"ue/8.html","title":"AirSim 数据图像收集","keywords":"","body":"AirSim 数据图像收集 Image APIs AirSim 中可以获得的图像包括： 单目 RGB 图像 双目深度图 分割图 红外图 [!DANGER] 这是一个危险信息由于是仿真模拟，深度图和分割图非常完美，并不能完全模拟显示中的不确定性。红外图是基于分割图生成的，需要自己定义每个物体的温度。 Scene = 0, DepthPlanar = 1, DepthPerspective = 2, DepthVis = 3, DisparityNormalized = 4, Segmentation = 5, SurfaceNormals = 6, Infrared = 7, OpticalFlow = 8, OpticalFlowVis = 9 图像类型 解释 用方式 Scene 彩色图 im.ImageType.Scene DepthPlanar 深度图，像素值代表到相平面的距离 airsim.ImageType.DepthPlanar DepthPerspective 深度图，像素值代表透视投影下到相平面的距离 airsim.ImageType.DepthPerspective DepthVis 深度图，为了更好的展示距离的远近，100 米对应白色，0 米对色 airsim.ImageType.DepthVis DisparityNormalized 深度视差图，每个像素值是浮点型 airsim.ImageType.DisparityNormalized Segmentation 分割图，不同 ID 号的物体用不同的颜色表示 airsim.ImageType.Segmentation SurfaceNormals 表面法线，包含了比较丰富的细节信息 airsim.ImageType.SurfaceNormals Infrared 红外图，与分割图类型，只是颜色变为 ID 号 airsim.ImageType.Infrared 相机的位置与 ID AirSim 平台中的无人机和无人车都默认放有 5 个相机，只是位置不同，本书主要介绍无人机上的相机。下表列出的是相机的位置和命名。旧版本的 AirSim 对相机的命名是使用的数字，目前 AirSim 兼容旧版本，所以使用数字也是可以的。 相机位置 ＩＤ 旧版本ＩＤ 前向中间 “front_center” “0” 前向右边 “front_right” 　 “1” 前向左边 “front_left” 　　 “2” 底部中间 “bottom_center” “3” 后向中间 “back_center” 　 “4” AirSim 中的 IMU 数据信息 IMU 输出的数据中的线速度和线加速度，是在世界坐标系下，即 NED 北-东-下坐标系。 IMU 加速度计测量加速度不包含重力加速度 如果 IMU 自由落体运动，不考虑噪声加速度计的读数是 0。 如果 IMU 静止在地面上，IMU 读数是 -9.8m/s2 如果 IMU 悬浮在空间，IMU 读数是 -9.8m/s2 AirSim 中如何生成 IMU 数据 AirSim 中，IMU 的读数输出对应两个坐标系: 机体坐标系: 采用 FLU 坐标系，主要是角速度和角加速度； 世界坐标系：采用 NED 坐标系，主要是其他的读数，包括线速度和加速度。 AirSim 通过程序来生成 IMU 数据，原理是获取 vehicle 状态和环境重力状态来计算，代码为：AirSim\\AirLib\\include\\sensors\\imu\\ImuSimple.hpp。 坐标变换函数的代码在 AirSim\\AirLib\\include\\common\\VectorMath.hpp void updateOutput() { Output output; //IMU生成的数据 // 第一步：获得vehicle的真值数据 const GroundTruth& ground_truth = getGroundTruth(); //得到无人机真值，包括*.kinematics动力学数据 // 第二步：获得角速度 output.angular_velocity = ground_truth.kinematics->twist.angular;//将无人机的角速度赋值给output.angular_velocity，FLU坐标系下 // 第三步：获得加速度 output.linear_acceleration = ground_truth.kinematics->accelerations.linear - ground_truth.environment->getState().gravity;//生成IMU加速度数据(世界坐标系NED)，IMU加速度不含重力加速度 // 第四步：获得位姿 output.orientation = ground_truth.kinematics->pose.orientation;// 得到无人机在世界系下的姿态 // 第五步：坐标转换？？ //acceleration is in world frame so transform to body frame output.linear_acceleration = VectorMath::transformToBodyFrame(output.linear_acceleration, ground_truth.kinematics->pose.orientation, true);// 将加速度转换为体坐标系下，这里使用表明Rwb后直接作为IMU数据，而没有Rbi，表明imu系与body系为同一系 // 第六步：add noise addNoise(output.linear_acceleration, output.angular_velocity); // TODO: Add noise in orientation? // 第七步：增加时间戳 output.time_stamp = clock()->nowNanos(); // 真实cpu时间?? setOutput(output); } AirSim 中如何读取 IMU 数据 msr::airlib::ImuBase::Output getImuData(const std::string& imu_name = \"\", const std::string& vehicle_name = \"\"); 读取 IMU 数据调用，相关源代码 AirSim/AirLib/include/sensors/imu/ImuBase.hpp imu_data = client.getImuData(imu_name = \"\", vehicle_name = \"\") Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-11-27 15:18:08 "},"ue/9.html":{"url":"ue/9.html","title":"坐标系 coordinate system","keywords":"","body":"坐标系 coordinate system AirSim API 的坐标系：NED 坐标系 with SI unit 所有 AirSim API 使用 NED 坐标系统，即+X 是北 North，+Y 是东 East，+Z 是下 Down。这意味着 Z 值越高越负：如果原点在地面上，z 值是零，地面以上是负的！ 所有单位都是国际单位制。 请注意，不同于 Unreal Engine （UE）内部使用的坐标系统。在 Unreal Engine 中，+Z 是向上 Up 而不是向下 Down，长度单位是厘米 cm 而不是米 m。 AirSim API 来完成从 Unreal Engine 的 NEU 坐标系到 AirSim 的 NED 坐标系的适当转换。在 AirSim NED 系统中，车辆的起始点总是坐标(0,0,0)。因此，当从 UE 坐标系转换到 AirSim NED 坐标系时，我们首先减去起始点偏移量，然后缩放 100 实现 cm 到 m 的转换。 在 UE 环境中，车辆由 Player Start component 放置的地方生成或衍生而来，在 Settings.json 配置文件中有一个设置项元素为 OriginGeopoint，可以将地理经度、纬度和海拔分配给 Player Start Component OriginGeoPoint 这指定了放置在 Unreal 环境中的 Player Start Component 的纬度、经度和高度。车辆的原点(home point)是用这个变换计算出来的。请注意，所有通过 API 采用的坐标都使用了以 SI 单位表示的 NED 坐标系统，这意味着每辆车在 NED 系统中都从(0,0,0)开始启动。参考官网：OriginGeopoint \"OriginGeopoint\": { \"Latitude\": 47.641468, \"Longitude\": -122.140165, \"Altitude\": 122 }, Unreal Engine 的坐标系 AirSim 不同于 Unreal Engine （UE）内部使用的坐标系统。在 Unreal Engine 中，+Z 是向上 Up 而不是向下 Down，长度单位是厘米 cm 而不是米 m。 用户不必特别关系 UE 坐标系，因为 AirSim 已经处理好了这个问题，即只需要按照 AirSim 坐标系设置即可，包括 Settings.json 中的 OriginGeopoint 元素，AirSim 会帮用户自动转换。 AirSim 全局坐标系 = NED 坐标系 = 世界坐标系 AirSim 的机体坐标系：Body Frame。遵循 Front Left Up (FLU)，右手法则 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-11-27 00:09:17 "},"ue/10.html":{"url":"ue/10.html","title":"settings","keywords":"","body":"settings [!TIP] AirSim 运行的时候会首先读取 settings 的设置信息，具体的设置信息参见官网：settings { \"SimMode\": \"\", // Car Multirotor ComputerVision \"ClockType\": \"\", \"ClockSpeed\": 1, \"LocalHostIp\": \"127.0.0.1\", \"ApiServerPort\": 41451, \"RecordUIVisible\": true, \"LogMessagesVisible\": true, \"ShowLosDebugLines\": false, \"ViewMode\": \"\", \"RpcEnabled\": true, \"EngineSound\": true, \"PhysicsEngineName\": \"\", \"SpeedUnitFactor\": 1.0, \"SpeedUnitLabel\": \"m/s\", \"Wind\": { \"X\": 0, \"Y\": 0, \"Z\": 0 }, \"CameraDirector\": { \"FollowDistance\": -3, \"X\": NaN, \"Y\": NaN, \"Z\": NaN, \"Pitch\": NaN, \"Roll\": NaN, \"Yaw\": NaN }, \"Recording\": { \"RecordOnMove\": false, \"RecordInterval\": 0.05, \"Folder\": \"\", \"Enabled\": false, \"Cameras\": [ { \"CameraName\": \"0\", \"ImageType\": 0, \"PixelsAsFloat\": false, \"VehicleName\": \"\", \"Compress\": true } ] }, \"CameraDefaults\": { \"CaptureSettings\": [ { \"ImageType\": 0, \"Width\": 256, \"Height\": 144, \"FOV_Degrees\": 90, \"AutoExposureSpeed\": 100, \"AutoExposureBias\": 0, \"AutoExposureMaxBrightness\": 0.64, \"AutoExposureMinBrightness\": 0.03, \"MotionBlurAmount\": 0, \"TargetGamma\": 1.0, \"ProjectionMode\": \"\", \"OrthoWidth\": 5.12 } ], \"NoiseSettings\": [ { \"Enabled\": false, \"ImageType\": 0, \"RandContrib\": 0.2, \"RandSpeed\": 100000.0, \"RandSize\": 500.0, \"RandDensity\": 2, \"HorzWaveContrib\": 0.03, \"HorzWaveStrength\": 0.08, \"HorzWaveVertSize\": 1.0, \"HorzWaveScreenSize\": 1.0, \"HorzNoiseLinesContrib\": 1.0, \"HorzNoiseLinesDensityY\": 0.01, \"HorzNoiseLinesDensityXY\": 0.5, \"HorzDistortionContrib\": 1.0, \"HorzDistortionStrength\": 0.002 } ], \"Gimbal\": { \"Stabilization\": 0, \"Pitch\": NaN, \"Roll\": NaN, \"Yaw\": NaN }, \"X\": NaN, \"Y\": NaN, \"Z\": NaN, \"Pitch\": NaN, \"Roll\": NaN, \"Yaw\": NaN, \"UnrealEngine\": { \"PixelFormatOverride\": [ { \"ImageType\": 0, \"PixelFormat\": 0 } ] } }, \"OriginGeopoint\": { // 设置仿真开始时候目标的经纬和高度 \"Latitude\": 47.641468, \"Longitude\": -122.140165, \"Altitude\": 122 }, \"TimeOfDay\": { // 设置太阳在环境中的位置 \"Enabled\": false, \"StartDateTime\": \"\", \"CelestialClockSpeed\": 1, \"StartDateTimeDst\": false, \"UpdateIntervalSecs\": 60 }, \"SubWindows\": [ // 子窗口显示的内容 { \"WindowID\": 0, \"CameraName\": \"0\", \"ImageType\": 3, \"VehicleName\": \"\", \"Visible\": false, \"External\": false }, { \"WindowID\": 1, \"CameraName\": \"0\", \"ImageType\": 5, \"VehicleName\": \"\", \"Visible\": false, \"External\": false }, { \"WindowID\": 2, \"CameraName\": \"0\", \"ImageType\": 0, \"VehicleName\": \"\", \"Visible\": false, \"External\": false } ], \"SegmentationSettings\": { \"InitMethod\": \"\", \"MeshNamingMethod\": \"\", \"OverrideExisting\": true }, \"PawnPaths\": { \"BareboneCar\": { \"PawnBP\": \"Class'/AirSim/VehicleAdv/Vehicle/VehicleAdvPawn.VehicleAdvPawn_C'\" }, \"DefaultCar\": { \"PawnBP\": \"Class'/AirSim/VehicleAdv/SUV/SuvCarPawn.SuvCarPawn_C'\" }, \"DefaultQuadrotor\": { \"PawnBP\": \"Class'/AirSim/Blueprints/BP_FlyingPawn.BP_FlyingPawn_C'\" }, \"DefaultComputerVision\": { \"PawnBP\": \"Class'/AirSim/Blueprints/BP_ComputerVisionPawn.BP_ComputerVisionPawn_C'\" } }, \"Vehicles\": { \"SimpleFlight\": { \"VehicleType\": \"SimpleFlight\", \"DefaultVehicleState\": \"Armed\", \"AutoCreate\": true, \"PawnPath\": \"\", \"EnableCollisionPassthrogh\": false, \"EnableCollisions\": true, \"AllowAPIAlways\": true, \"EnableTrace\": false, \"RC\": { \"RemoteControlID\": 0, \"AllowAPIWhenDisconnected\": false }, \"Cameras\": { //same elements as CameraDefaults above, key as name }, \"X\": NaN, \"Y\": NaN, \"Z\": NaN, \"Pitch\": NaN, \"Roll\": NaN, \"Yaw\": NaN }, \"PhysXCar\": { \"VehicleType\": \"PhysXCar\", \"DefaultVehicleState\": \"\", \"AutoCreate\": true, \"PawnPath\": \"\", \"EnableCollisionPassthrogh\": false, \"EnableCollisions\": true, \"RC\": { \"RemoteControlID\": -1 }, \"Cameras\": { \"MyCamera1\": { //same elements as elements inside CameraDefaults above }, \"MyCamera2\": { //same elements as elements inside CameraDefaults above } }, \"X\": NaN, \"Y\": NaN, \"Z\": NaN, \"Pitch\": NaN, \"Roll\": NaN, \"Yaw\": NaN } }, \"ExternalCameras\": { \"FixedCamera1\": { // same elements as in CameraDefaults above }, \"FixedCamera2\": { // same elements as in CameraDefaults above } } } Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-11-27 14:56:03 "},"ue/doing.html":{"url":"ue/doing.html","title":"后续工作","keywords":"","body":"后续工作 像真实的无人机一样采取一堆自上而下的数据图像：Implementing a Drone Survey script 通过 AirSim 得到的深度图像信息转化为点云：Point Clouds 对象检测：Object Detection AirSim 官方还提供了很多类似的教程都在： Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-11-26 23:46:07 "},"work/":{"url":"work/","title":"工作记录一","keywords":"","body":"工作日志一 API 输入问题 1. 客户端： F:\\AirSim\\AirLib\\include\\vehicles\\multirotor\\api\\MultirotorRpcLibClient.hpp msr -> airlib -> MultirotorRpcLibClient -> moveToGPSAsync MultirotorRpcLibClient* moveToGPSAsync(float latitude, float longitude, float altitude, float velocity, float timeout_sec = Utils::max(), DrivetrainType drivetrain = DrivetrainType::MaxDegreeOfFreedom, const YawMode& yaw_mode = YawMode(), float lookahead = -1, float adaptive_lookahead = 1, const std::string& vehicle_name = \"\"); 2. 服务端： F:\\AirSim\\AirLib\\src\\vehicles\\multirotor\\api\\MultirotorRpcLibServer.cpp msr -> airlib -> MultirotorRpcLibServer -> moveToGPS (static_cast(getServer()))->bind(\"moveToGPS\", [&](float latitude, float longitude, float altitude, float velocity, float timeout_sec, DrivetrainType drivetrain, const MultirotorRpcLibAdaptors::YawMode& yaw_mode, float lookahead, float adaptive_lookahead, const std::string& vehicle_name) -> bool { return getVehicleApi(vehicle_name)->moveToGPS(latitude, longitude, altitude, velocity, timeout_sec, drivetrain, yaw_mode.to(),lookahead, adaptive_lookahead); }); 3. 服务端实现 getVehicleApi(vehicle_name) -> moveToGPS F:\\AirSim\\AirLib\\src\\vehicles\\multirotor\\api\\MultirotorApiBase.cpp msr -> airlib -> moveToGPS bool MultirotorApiBase::moveToGPS(float latitude, float longitude, float altitude, float velocity, float timeout_sec, DrivetrainTypedrivetrain, const YawMode& yaw_mode, float lookahead, float adaptive_lookahead) { SingleTaskCall lock(this); GeoPoint target; target.latitude = latitude; target.longitude = longitude; target.altitude = altitude; if (!std::isnan(getHomeGeoPoint().latitude) && !std::isnan(getHomeGeoPoint().longitude) && !std::isnan(getHomeGeoPoint()altitude)) { vector path{ msr::airlib::EarthUtils::GeodeticToNed(target, getHomeGeoPoint()) }; return moveOnPath(path, velocity, timeout_sec, drivetrain, yaw_mode, lookahead, adaptive_lookahead); } else { vector path{ Vector3r(getPosition().x(), getPosition().y(), getPosition().z()) }; return moveOnPath(path, velocity, timeout_sec, drivetrain, yaw_mode, lookahead, adaptive_lookahead); } } 客户端程序调用 API -> 客户端将消息封装为 msgpack-rpc 消息包发送出去，向服务端请求 -> 服务端通过 bind 绑定 ，返回 return getVehicleApi(vehicle_name)->moveToGPS // GpsBase.hpp struct GnssReport { GeoPoint geo_point; real_T eph, epv; //GPS HDOP/VDOP horizontal/vertical dilution of position (unitless), 0-100% 。GPS HDOP/VDOP水平/垂直位置稀释度(单位无)，0-100% Vector3r velocity; GnssFixType fix_type; uint64_t time_utc = 0; }; struct Output { //same as ROS message TTimePoint time_stamp; GnssReport gnss; bool is_valid = false; }; // GpsSimple.hpp Output output; //GNSS 全球导航卫星系统 output.gnss.time_utc = static_cast(clock()->nowNanos() / 1.0E3); output.gnss.geo_point = ground_truth.environment->getState().geo_point; output.gnss.eph = eph; output.gnss.epv = epv; output.gnss.velocity = ground_truth.kinematics->twist.linear; output.is_valid = true; 卡顿问题 现在初步判断是 msgpack-rpc 协议的问题（线程） 设置更新问题 可以直接在 unity 中添加无人机（直接复制原先环境中的无人机），并更新 setting 设置，这个与引擎有关 注意 Vehicle Name 要与设置中的名字对应！ 数据结构 client.getMultirotorState() state: { 'collision': {'has_collided': False, 'impact_point': {'x_val': 0.0, 'y_val': 0.0, 'z_val': 0.0}, 'normal': {'x_val': 0.0, 'y_val': 0.0, 'z_val': 0.0}, 'object_id': -1, 'object_name': '', 'penetration_depth': 0.0, 'position': {'x_val': 0.0, 'y_val': 0.0, 'z_val': 0.0}, 'time_stamp': 0 }, 'gps_location': { 'altitude': 75.36256408691406, 'latitude': 47.64146799999126, 'longitude': -122.14021828176107 }, 'kinematics_estimated': { 'angular_acceleration': { 'x_val': 0.0, 'y_val': 0.0, 'z_val': 0.0 }, 'angular_velocity': { 'x_val': 0.0, 'y_val': 0.0, 'z_val': 0.0 }, 'linear_acceleration': { 'x_val': 0.0, 'y_val': 0.0, 'z_val': 0.0 }, 'linear_velocity': { 'x_val': 0.0, 'y_val': 0.0, 'z_val': 0.0 }, 'orientation': { 'w_val': 1.0, 'x_val': 0.0, 'y_val': 0.0, 'z_val': 0.0 }, 'position': { 'x_val': 0.0, 'y_val': -2.0, 'z_val': 47.63752365112305 } }, 'landed_state': 0, 'rc_data': { 'is_initialized': False, 'is_valid': False, 'left_z': 0.0, 'pitch': 0.0, 'right_z': 0.0, 'roll': 0.0, 'switches': 0, 'throttle': 0.0, 'timestamp': 0, 'vendor_id': '', 'yaw': 0.0 }, 'timestamp': 1672127743136258048 } client.getImuData() imu_data: { 'angular_velocity': { 'x_val': -0.002116621006280184, 'y_val': -0.001679769135080278, 'z_val': -0.001852852408774197 }, 'linear_acceleration': { 'x_val': 0.005482715088874102, 'y_val': -0.025000527501106262, 'z_val': -9.773659706115723 }, 'orientation': { 'w_val': 1.0, 'x_val': 0.0, 'y_val': 0.0, 'z_val': 0.0 }, 'time_stamp': 1672127743142258176 } client.getBarometerData() barometer_data: { 'altitude': 75.66569519042969, 'pressure': 100418.9375, 'qnh': 1013.25, 'time_stamp': 1672127743127257856 } client.getMagnetometerData() magnetometer_data: { 'magnetic_field_body': { 'x_val': 0.24865034222602844, 'y_val': 0.042973004281520844, 'z_val': 0.3683101236820221 }, 'magnetic_field_covariance': [ ], 'time_stamp': 1672127743148258304 } client.getGpsData() gps_data: { 'gnss': { 'eph': 0.11096888780593872, 'epv': 0.11096888780593872, 'fix_type': 3, 'geo_point': { 'altitude': 75.36256408691406, 'latitude': 47.64146799999126, 'longitude': -122.14021828176107 }, 'time_utc': 1672127742932253, 'velocity': { 'x_val': 0.0, 'y_val': 0.0, 'z_val': 0.0 } }, 'is_valid': True, 'time_stamp': 1672127742932253696 } 源码阅读 -> Assets\\AirSimAssets\\Scripts\\Vehicles\\Multirotor\\Drone.cs /* 无人机组件，用于控制场景中的无人机对象。这是基于与 AirLib 通信的 Vehicle 类。 这个类依赖于 AirLib 的基于 FastPhysics 引擎的无人机控制器。控制器正在按设置使用。Documents\\AirSim . json文件 无人机可以通过键盘或通过客户端 api 调用来控制。 此数据通过 PInvoke 委托在 AirLib 和 Unity 之间不断交换。 */ 数据通过 PInvoke 委托在 AirLib 和 Unity 之间不断交换。 C# 与 C/C++的交互（PInvoke） Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-12-28 10:46:50 "},"work/1.html":{"url":"work/1.html","title":"工作日志二","keywords":"","body":"工作日志二 Airsim 结构框架 阿木实验室 - 带你了解 Airsim 结构框架 AirSim 设计官方介绍 AirSim 代码结构介绍 AirSim 论文 IMU 数据 理解 IMU 的输出数据 IMU 输出的数据中的线速度和线加速度，是在世界坐标系下，即 NED 北-东-下坐标系。 IMU 加速度计测量加速度不包含重力加速度 如果 IMU 自由落体运动，不考虑噪声加速度计的读数是 0。 如果 IMU 静止在地面上，IMU 读数是-9.8m/s2 如果 IMU 悬浮在空间，IMU 读数是-9.8m/s2 关于 IMU 加速度读数不包含重力加速度的理解：issues#4303; 以及 IMU 原理；和 IMU 传感器。来自引用文献{issues#4303]的解释：可以这样认为，IMU 的内部运行可以理解为一个盒子，里面有一个质量悬浮在两个弹簧之间，质量的位置对应了 IMU 的输出。当这个盒子（IMU）坐在一张桌子上，作用力会推/拉在其内部的质量弹簧 ：因为质量会引起重力加速度，但是盒子是静止的，这是由于盒子受到桌面的法向/接触力。这就像质量将推/拉弹簧向下（+z 方向），而同时由于存在一个向上的作用力引起的加速度 (因为惯性)，整个盒子加速度为 0，但是 IMU 读起来都是向上（-Z 方向）的。 对于自由落下的盒子，质量将受到重力朝向中心位置，这里没有推/拉弹簧：现在质量和盒子都被重力同样加速，一个与另一个在受力上没有不同)，IMU 最终读到的是 0 加速度，反映它如何不再受地面法向力/接触力的影响。本质上，因为 IMU 的读数取决于盒子和里面的质量之间的力的差异，所以重力只能根据作用在盒子上的法向/接触力来测量(方向相反，大小相同)。 AirSim 中如何生成 IMU 数据 AirSim 中，IMU 的读数输出对应两个坐标系: 机体坐标系: 采用 FLU 坐标系，主要是角速度和角加速度； 世界坐标系：采用 NED 坐标系，主要是其他的读数，包括线速度和加速度。 AirSim 通过程序来生成 IMU 数据，原理是获取 vehicle 状态和环境重力状态来计算，代码为：AirLib\\include\\sensors\\imu\\ImuSimple.hpp void updateOutput() { Output output; //IMU生成的数据 // 第一步：获得vehicle的真值数据 const GroundTruth& ground_truth = getGroundTruth(); //得到无人机真值，包括*.kinematics动力学数据 // 第二步：获得角速度 output.angular_velocity = ground_truth.kinematics->twist.angular;//将无人机的角速度赋值给output.angular_velocity，FLU坐标系下 // 第三步：获得加速度 output.linear_acceleration = ground_truth.kinematics->accelerations.linear - ground_truth.environment->getState().gravity;//生成IMU加速度数据(世界坐标系NED)，IMU加速度不含重力加速度 // 第四步：获得位姿 output.orientation = ground_truth.kinematics->pose.orientation;// 得到无人机在世界系下的姿态 // 第五步：坐标转换？？ //acceleration is in world frame so transform to body frame output.linear_acceleration = VectorMath::transformToBodyFrame(output.linear_acceleration, ground_truth.kinematics->pose.orientation, true);// 将加速度转换为体坐标系下，这里使用表明Rwb后直接作为IMU数据，而没有Rbi，表明imu系与body系为同一系 // 第六步：add noise addNoise(output.linear_acceleration, output.angular_velocity); // TODO: Add noise in orientation? // 第七步：增加时间戳 output.time_stamp = clock()->nowNanos(); // 真实cpu时间?? setOutput(output); } 坐标变换函数的代码，在 AirSim/AirLib/include/common/VectorMath.hpp 中 GPS 数据 GPS 的工作原理 首先，宇宙里的卫星会不停的向地面的 GPS 接收机（常用的 GPS 模块）广播当前的位置信息，包括该数据包的时间戳，当 GPS 模块接收到这些信息后，用当前时间减去时间戳的时间，就得到空中传输的时间，乘上传输速度，就得到卫星与 GPS 模块的距离。 理论来讲，为了确定 GPS 模块的坐标位置（NEH），3 个参数，那只需要 3 颗卫星与 GPS 模块的距离就可以计算出来。 但是因为对时间差的要求特别高，由于 GPS 模块的时钟一般是石英钟，所以认为它的时钟时间与卫星的时间有同步误差，所以加上这个误差作为参数，这样就有 4 个参数待定，所以一般至少需要 4 颗卫星进行观测。 GPS 的输出协议 以 M8N 模块为例，有 NMEA、UBX、RTCM3 种。默认 NMEA、UBX 两种协议都已使能，但是输出的只有 NMEA 协议，这个协议是 ASCII 码形式输出，如果与电脑上位机进行通讯时，用这种方式解析比较方便，但如果是嵌入式单片机（飞控一般属于此类）与 GPS 模块进行通信，一般用 UBX 协议，其输出格式是二进制。 AirSim 中的 GPS 数据生成 AirLib\\include\\sensors\\gps\\GpsSimple.hpp void addOutputToDelayLine(real_T eph, real_T epv) { Output output; const GroundTruth& ground_truth = getGroundTruth(); // 得到无人机真值，包括*.kinematics动力学数 //GNSS 全球导航卫星系统 output.gnss.time_utc = static_cast(clock()->nowNanos() / 1.0E3); // ground_truth 地面信息 getGroundTruth(); 地面信息可以在多个传感器之间共享 output.gnss.geo_point = ground_truth.environment->getState().geo_point; output.gnss.eph = eph; output.gnss.epv = epv; output.gnss.velocity = ground_truth.kinematics->twist.linear; output.is_valid = true output.gnss.fix_type = output.gnss.eph nowNanos() delay_line_.push_back(output); } 通过查找 const GroundTruth& ground_truth = getGroundTruth(); output.gnss.geo_point = ground_truth.environment->getState().geo_point; 可得在 Environment.hpp 中可以找到, 可以看到 GPS 信息就是在这定义和更新的，AirLib\\include\\physics\\Environment.hpp 中的 geo_point 即是 GPS 信息 geo_point 的更新在 AirLib\\include\\common\\EarthUtils.hpp 中实现 传感器源码解读 从以上两个传感器的源码阅读来看 传感器的数据类型定义等在 xxxBase.hpp 传感器模型的实现在 xxxSimple.hpp 传感器初始化等其他在 xxxSimpleParams.hpp 中有实现 所有传感器的共同部分都在 SensorBase.hpp SensorCollection.hpp SensorFatory.hpp 中定义 由上面两个传感器的实现看，它们首先都读取了 无人机真值，包括*.kinematics 动力学数 const GroundTruth& ground_truth = getGroundTruth(); // 得到无人机真值，包括*.kinematics动力学数 数据结果如下 { // SensorBase.hpp 中定义 struct GroundTruth { const Kinematics::State* kinematics; // class Kinematics : public UpdatableObject 在物理系统的 Kinematics.hpp 中定义 const Environment* environment; // class Environment : public UpdatableObject 在物理引擎的 Environment.hpp 中定义 }; private: //ground truth can be shared between many sensors // 地面信息可以在多传感器中共享 GroundTruth ground_truth_ = { nullptr, nullptr }; std::string name_ = \"\"; }; 传感器模型的创建：SensorFatory.hpp // creates one sensor from settings virtual std::shared_ptr createSensorFromSettings( const AirSimSettings::SensorSetting* sensor_setting) const { switch (sensor_setting->sensor_type) { case SensorBase::SensorType::Imu: return std::shared_ptr(new ImuSimple(*static_cast(sensor_setting))); case SensorBase::SensorType::Magnetometer: return std::shared_ptr(new MagnetometerSimple(*static_cast(sensor_setting))); case SensorBase::SensorType::Gps: return std::shared_ptr(new GpsSimple(*static_cast(sensor_setting))); case SensorBase::SensorType::Barometer: return std::shared_ptr(new BarometerSimple(*static_cast 传感器初始化SensorCollection.hpp, 在这里可以看出传感器需要传递的参数就是数据结构 GroundTruth 中的参数 void initialize(const Kinematics::State* kinematics, const Environment* environment) { for (auto& pair : sensors_) { for (auto& sensor : *pair.second) { sensor->initialize(kinematics, environment); } } } Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-12-28 13:20:11 "}}